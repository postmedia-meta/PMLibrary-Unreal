//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: meta.lib.proto.fbe
// FBE version: 1.14.2.0
//------------------------------------------------------------------------------

#include "proto/proto.h"

namespace proto {

MetaPacket::MetaPacket()
    : type()
    , number()
    , text()
{}

MetaPacket::MetaPacket(const std::string& arg_type, const std::optional<int32_t>& arg_number, const std::optional<std::string>& arg_text)
    : type(arg_type)
    , number(arg_number)
    , text(arg_text)
{}

bool MetaPacket::operator==(const MetaPacket& other) const noexcept
{
    return (
        true
        );
}

bool MetaPacket::operator<(const MetaPacket& other) const noexcept
{
    return false;
}

void MetaPacket::swap(MetaPacket& other) noexcept
{
    using std::swap;
    swap(type, other.type);
    swap(number, other.number);
    swap(text, other.text);
}

std::ostream& operator<<(std::ostream& stream, const MetaPacket& value)
{
    stream << "MetaPacket(";
    stream << "type="; stream << "\"" << value.type << "\"";
    stream << ",number="; if (value.number) stream << *value.number; else stream << "null";
    stream << ",text="; if (value.text) stream << "\"" << *value.text << "\""; else stream << "null";
    stream << ")";
    return stream;
}

MetaBinaryPacket::MetaBinaryPacket()
    : type()
    , data()
    , info()
{}

MetaBinaryPacket::MetaBinaryPacket(const std::string& arg_type, const FBE::buffer_t& arg_data, const std::optional<std::string>& arg_info)
    : type(arg_type)
    , data(arg_data)
    , info(arg_info)
{}

bool MetaBinaryPacket::operator==(const MetaBinaryPacket& other) const noexcept
{
    return (
        true
        );
}

bool MetaBinaryPacket::operator<(const MetaBinaryPacket& other) const noexcept
{
    return false;
}

void MetaBinaryPacket::swap(MetaBinaryPacket& other) noexcept
{
    using std::swap;
    swap(type, other.type);
    swap(data, other.data);
    swap(info, other.info);
}

std::ostream& operator<<(std::ostream& stream, const MetaBinaryPacket& value)
{
    stream << "MetaBinaryPacket(";
    stream << "type="; stream << "\"" << value.type << "\"";
    stream << ",data="; stream << "bytes[" << value.data.size() << "]";
    stream << ",info="; if (value.info) stream << "\"" << *value.info << "\""; else stream << "null";
    stream << ")";
    return stream;
}

LiDARPosition::LiDARPosition()
    : idx((int32_t)0ll)
    , x((int32_t)0ll)
    , y((int32_t)0ll)
    , originPercentX(0.0f)
    , originPercentY(0.0f)
    , percentX(0.0f)
    , percentY(0.0f)
{}

LiDARPosition::LiDARPosition(int32_t arg_idx, int32_t arg_x, int32_t arg_y, float arg_originPercentX, float arg_originPercentY, float arg_percentX, float arg_percentY)
    : idx(arg_idx)
    , x(arg_x)
    , y(arg_y)
    , originPercentX(arg_originPercentX)
    , originPercentY(arg_originPercentY)
    , percentX(arg_percentX)
    , percentY(arg_percentY)
{}

bool LiDARPosition::operator==(const LiDARPosition& other) const noexcept
{
    return (
        (idx == other.idx)
        );
}

bool LiDARPosition::operator<(const LiDARPosition& other) const noexcept
{
    if (idx < other.idx)
        return true;
    if (other.idx < idx)
        return false;
    return false;
}

void LiDARPosition::swap(LiDARPosition& other) noexcept
{
    using std::swap;
    swap(idx, other.idx);
    swap(x, other.x);
    swap(y, other.y);
    swap(originPercentX, other.originPercentX);
    swap(originPercentY, other.originPercentY);
    swap(percentX, other.percentX);
    swap(percentY, other.percentY);
}

std::ostream& operator<<(std::ostream& stream, const LiDARPosition& value)
{
    stream << "LiDARPosition(";
    stream << "idx="; stream << value.idx;
    stream << ",x="; stream << value.x;
    stream << ",y="; stream << value.y;
    stream << ",originPercentX="; stream << value.originPercentX;
    stream << ",originPercentY="; stream << value.originPercentY;
    stream << ",percentX="; stream << value.percentX;
    stream << ",percentY="; stream << value.percentY;
    stream << ")";
    return stream;
}

LiDARFrameData::LiDARFrameData()
    : screen()
    , newTouches()
    , removeTouches()
    , updateTouches()
{}

LiDARFrameData::LiDARFrameData(const std::string& arg_screen, const std::list<::proto::LiDARPosition>& arg_newTouches, const std::list<::proto::LiDARPosition>& arg_removeTouches, const std::list<::proto::LiDARPosition>& arg_updateTouches)
    : screen(arg_screen)
    , newTouches(arg_newTouches)
    , removeTouches(arg_removeTouches)
    , updateTouches(arg_updateTouches)
{}

bool LiDARFrameData::operator==(const LiDARFrameData& other) const noexcept
{
    return (
        true
        );
}

bool LiDARFrameData::operator<(const LiDARFrameData& other) const noexcept
{
    return false;
}

void LiDARFrameData::swap(LiDARFrameData& other) noexcept
{
    using std::swap;
    swap(screen, other.screen);
    swap(newTouches, other.newTouches);
    swap(removeTouches, other.removeTouches);
    swap(updateTouches, other.updateTouches);
}

std::ostream& operator<<(std::ostream& stream, const LiDARFrameData& value)
{
    stream << "LiDARFrameData(";
    stream << "screen="; stream << "\"" << value.screen << "\"";
    {
        bool first = true;
        stream << ",newTouches=[" << value.newTouches.size()<< "]<";
        for (const auto& it : value.newTouches)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",removeTouches=[" << value.removeTouches.size()<< "]<";
        for (const auto& it : value.removeTouches)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",updateTouches=[" << value.updateTouches.size()<< "]<";
        for (const auto& it : value.updateTouches)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << ">";
    }
    stream << ")";
    return stream;
}

MetaMessage::MetaMessage()
    : body()
{}

MetaMessage::MetaMessage(const ::proto::MetaPacket& arg_body)
    : body(arg_body)
{}

bool MetaMessage::operator==(const MetaMessage& other) const noexcept
{
    return (
        true
        );
}

bool MetaMessage::operator<(const MetaMessage& other) const noexcept
{
    return false;
}

void MetaMessage::swap(MetaMessage& other) noexcept
{
    using std::swap;
    swap(body, other.body);
}

std::ostream& operator<<(std::ostream& stream, const MetaMessage& value)
{
    stream << "MetaMessage(";
    stream << "body="; stream << value.body;
    stream << ")";
    return stream;
}

MetaBinaryMessage::MetaBinaryMessage()
    : body()
{}

MetaBinaryMessage::MetaBinaryMessage(const ::proto::MetaBinaryPacket& arg_body)
    : body(arg_body)
{}

bool MetaBinaryMessage::operator==(const MetaBinaryMessage& other) const noexcept
{
    return (
        true
        );
}

bool MetaBinaryMessage::operator<(const MetaBinaryMessage& other) const noexcept
{
    return false;
}

void MetaBinaryMessage::swap(MetaBinaryMessage& other) noexcept
{
    using std::swap;
    swap(body, other.body);
}

std::ostream& operator<<(std::ostream& stream, const MetaBinaryMessage& value)
{
    stream << "MetaBinaryMessage(";
    stream << "body="; stream << value.body;
    stream << ")";
    return stream;
}

LiDARMapperMessage::LiDARMapperMessage()
    : body()
{}

LiDARMapperMessage::LiDARMapperMessage(const ::proto::LiDARFrameData& arg_body)
    : body(arg_body)
{}

bool LiDARMapperMessage::operator==(const LiDARMapperMessage& other) const noexcept
{
    return (
        true
        );
}

bool LiDARMapperMessage::operator<(const LiDARMapperMessage& other) const noexcept
{
    return false;
}

void LiDARMapperMessage::swap(LiDARMapperMessage& other) noexcept
{
    using std::swap;
    swap(body, other.body);
}

std::ostream& operator<<(std::ostream& stream, const LiDARMapperMessage& value)
{
    stream << "LiDARMapperMessage(";
    stream << "body="; stream << value.body;
    stream << ")";
    return stream;
}

} // namespace proto
