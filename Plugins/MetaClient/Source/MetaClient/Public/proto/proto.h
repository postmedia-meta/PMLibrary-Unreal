//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: meta.lib.proto.fbe
// FBE version: 1.14.2.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace proto {
using namespace FBE;
} // namespace proto

namespace FBE {
using namespace ::proto;
} // namespace FBE

namespace proto {

struct MetaPacket
{
    std::string type;
    std::optional<int32_t> number;
    std::optional<std::string> text;

    size_t fbe_type() const noexcept { return 1; }

    MetaPacket();
    MetaPacket(const std::string& arg_type, const std::optional<int32_t>& arg_number, const std::optional<std::string>& arg_text);
    MetaPacket(const MetaPacket& other) = default;
    MetaPacket(MetaPacket&& other) = default;
    ~MetaPacket() = default;

    MetaPacket& operator=(const MetaPacket& other) = default;
    MetaPacket& operator=(MetaPacket&& other) = default;

    bool operator==(const MetaPacket& other) const noexcept;
    bool operator!=(const MetaPacket& other) const noexcept { return !operator==(other); }
    bool operator<(const MetaPacket& other) const noexcept;
    bool operator<=(const MetaPacket& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MetaPacket& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MetaPacket& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MetaPacket& value);

    void swap(MetaPacket& other) noexcept;
    friend void swap(MetaPacket& value1, MetaPacket& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MetaPacket> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MetaPacket>
{
    typedef proto::MetaPacket argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct MetaBinaryPacket
{
    std::string type;
    FBE::buffer_t data;
    std::optional<std::string> info;

    size_t fbe_type() const noexcept { return 2; }

    MetaBinaryPacket();
    MetaBinaryPacket(const std::string& arg_type, const FBE::buffer_t& arg_data, const std::optional<std::string>& arg_info);
    MetaBinaryPacket(const MetaBinaryPacket& other) = default;
    MetaBinaryPacket(MetaBinaryPacket&& other) = default;
    ~MetaBinaryPacket() = default;

    MetaBinaryPacket& operator=(const MetaBinaryPacket& other) = default;
    MetaBinaryPacket& operator=(MetaBinaryPacket&& other) = default;

    bool operator==(const MetaBinaryPacket& other) const noexcept;
    bool operator!=(const MetaBinaryPacket& other) const noexcept { return !operator==(other); }
    bool operator<(const MetaBinaryPacket& other) const noexcept;
    bool operator<=(const MetaBinaryPacket& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MetaBinaryPacket& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MetaBinaryPacket& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MetaBinaryPacket& value);

    void swap(MetaBinaryPacket& other) noexcept;
    friend void swap(MetaBinaryPacket& value1, MetaBinaryPacket& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MetaBinaryPacket> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MetaBinaryPacket>
{
    typedef proto::MetaBinaryPacket argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct LiDARPosition
{
    int32_t idx;
    int32_t x;
    int32_t y;
    float originPercentX;
    float originPercentY;
    float percentX;
    float percentY;

    size_t fbe_type() const noexcept { return 10; }

    LiDARPosition();
    LiDARPosition(int32_t arg_idx, int32_t arg_x, int32_t arg_y, float arg_originPercentX, float arg_originPercentY, float arg_percentX, float arg_percentY);
    LiDARPosition(const LiDARPosition& other) = default;
    LiDARPosition(LiDARPosition&& other) = default;
    ~LiDARPosition() = default;

    LiDARPosition& operator=(const LiDARPosition& other) = default;
    LiDARPosition& operator=(LiDARPosition&& other) = default;

    bool operator==(const LiDARPosition& other) const noexcept;
    bool operator!=(const LiDARPosition& other) const noexcept { return !operator==(other); }
    bool operator<(const LiDARPosition& other) const noexcept;
    bool operator<=(const LiDARPosition& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const LiDARPosition& other) const noexcept { return !operator<=(other); }
    bool operator>=(const LiDARPosition& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const LiDARPosition& value);

    void swap(LiDARPosition& other) noexcept;
    friend void swap(LiDARPosition& value1, LiDARPosition& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::LiDARPosition> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::LiDARPosition>
{
    typedef proto::LiDARPosition argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.idx)>()(value.idx);
        return result;
    }
};

namespace proto {

struct LiDARFrameData
{
    std::string screen;
    std::list<::proto::LiDARPosition> newTouches;
    std::list<::proto::LiDARPosition> removeTouches;
    std::list<::proto::LiDARPosition> updateTouches;

    size_t fbe_type() const noexcept { return 11; }

    LiDARFrameData();
    LiDARFrameData(const std::string& arg_screen, const std::list<::proto::LiDARPosition>& arg_newTouches, const std::list<::proto::LiDARPosition>& arg_removeTouches, const std::list<::proto::LiDARPosition>& arg_updateTouches);
    LiDARFrameData(const LiDARFrameData& other) = default;
    LiDARFrameData(LiDARFrameData&& other) = default;
    ~LiDARFrameData() = default;

    LiDARFrameData& operator=(const LiDARFrameData& other) = default;
    LiDARFrameData& operator=(LiDARFrameData&& other) = default;

    bool operator==(const LiDARFrameData& other) const noexcept;
    bool operator!=(const LiDARFrameData& other) const noexcept { return !operator==(other); }
    bool operator<(const LiDARFrameData& other) const noexcept;
    bool operator<=(const LiDARFrameData& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const LiDARFrameData& other) const noexcept { return !operator<=(other); }
    bool operator>=(const LiDARFrameData& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const LiDARFrameData& value);

    void swap(LiDARFrameData& other) noexcept;
    friend void swap(LiDARFrameData& value1, LiDARFrameData& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::LiDARFrameData> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::LiDARFrameData>
{
    typedef proto::LiDARFrameData argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct MetaMessage
{
    ::proto::MetaPacket body;

    size_t fbe_type() const noexcept { return 1; }

    MetaMessage();
    explicit MetaMessage(const ::proto::MetaPacket& arg_body);
    MetaMessage(const MetaMessage& other) = default;
    MetaMessage(MetaMessage&& other) = default;
    ~MetaMessage() = default;

    MetaMessage& operator=(const MetaMessage& other) = default;
    MetaMessage& operator=(MetaMessage&& other) = default;

    bool operator==(const MetaMessage& other) const noexcept;
    bool operator!=(const MetaMessage& other) const noexcept { return !operator==(other); }
    bool operator<(const MetaMessage& other) const noexcept;
    bool operator<=(const MetaMessage& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MetaMessage& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MetaMessage& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MetaMessage& value);

    void swap(MetaMessage& other) noexcept;
    friend void swap(MetaMessage& value1, MetaMessage& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MetaMessage> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MetaMessage>
{
    typedef proto::MetaMessage argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct MetaBinaryMessage
{
    ::proto::MetaBinaryPacket body;

    size_t fbe_type() const noexcept { return 2; }

    MetaBinaryMessage();
    explicit MetaBinaryMessage(const ::proto::MetaBinaryPacket& arg_body);
    MetaBinaryMessage(const MetaBinaryMessage& other) = default;
    MetaBinaryMessage(MetaBinaryMessage&& other) = default;
    ~MetaBinaryMessage() = default;

    MetaBinaryMessage& operator=(const MetaBinaryMessage& other) = default;
    MetaBinaryMessage& operator=(MetaBinaryMessage&& other) = default;

    bool operator==(const MetaBinaryMessage& other) const noexcept;
    bool operator!=(const MetaBinaryMessage& other) const noexcept { return !operator==(other); }
    bool operator<(const MetaBinaryMessage& other) const noexcept;
    bool operator<=(const MetaBinaryMessage& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MetaBinaryMessage& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MetaBinaryMessage& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const MetaBinaryMessage& value);

    void swap(MetaBinaryMessage& other) noexcept;
    friend void swap(MetaBinaryMessage& value1, MetaBinaryMessage& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::MetaBinaryMessage> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::MetaBinaryMessage>
{
    typedef proto::MetaBinaryMessage argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct LiDARMapperMessage
{
    ::proto::LiDARFrameData body;

    size_t fbe_type() const noexcept { return 3; }

    LiDARMapperMessage();
    explicit LiDARMapperMessage(const ::proto::LiDARFrameData& arg_body);
    LiDARMapperMessage(const LiDARMapperMessage& other) = default;
    LiDARMapperMessage(LiDARMapperMessage&& other) = default;
    ~LiDARMapperMessage() = default;

    LiDARMapperMessage& operator=(const LiDARMapperMessage& other) = default;
    LiDARMapperMessage& operator=(LiDARMapperMessage&& other) = default;

    bool operator==(const LiDARMapperMessage& other) const noexcept;
    bool operator!=(const LiDARMapperMessage& other) const noexcept { return !operator==(other); }
    bool operator<(const LiDARMapperMessage& other) const noexcept;
    bool operator<=(const LiDARMapperMessage& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const LiDARMapperMessage& other) const noexcept { return !operator<=(other); }
    bool operator>=(const LiDARMapperMessage& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const LiDARMapperMessage& value);

    void swap(LiDARMapperMessage& other) noexcept;
    friend void swap(LiDARMapperMessage& value1, LiDARMapperMessage& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::LiDARMapperMessage> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::LiDARMapperMessage>
{
    typedef proto::LiDARMapperMessage argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

} // namespace proto
