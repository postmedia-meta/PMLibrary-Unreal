//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: meta.lib.proto.fbe
// FBE version: 1.14.2.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe_models.h"

#include "proto.h"

namespace FBE {

// Fast Binary Encoding ::proto::MetaPacket field model
template <>
class FieldModel<::proto::MetaPacket>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool Verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::proto::MetaPacket& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::proto::MetaPacket& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::proto::MetaPacket& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::proto::MetaPacket& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<std::string> type;
    FieldModel<std::optional<int32_t>> number;
    FieldModel<std::optional<std::string>> text;
};

namespace proto {

// Fast Binary Encoding MetaPacket model
class MetaPacketModel : public FBE::Model
{
public:
    MetaPacketModel() : model(this->buffer(), 4) {}
    MetaPacketModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::proto::MetaPacket>::fbe_type(); }

    // Check if the struct value is valid
    bool Verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::proto::MetaPacket& value);
    // Deserialize the struct value
    size_t deserialize(::proto::MetaPacket& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::proto::MetaPacket> model;
};

} // namespace proto

// Fast Binary Encoding ::proto::MetaBinaryPacket field model
template <>
class FieldModel<::proto::MetaBinaryPacket>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 2; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool Verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::proto::MetaBinaryPacket& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::proto::MetaBinaryPacket& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::proto::MetaBinaryPacket& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::proto::MetaBinaryPacket& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<std::string> type;
    FieldModel<FBE::buffer_t> data;
    FieldModel<std::optional<std::string>> info;
};

namespace proto {

// Fast Binary Encoding MetaBinaryPacket model
class MetaBinaryPacketModel : public FBE::Model
{
public:
    MetaBinaryPacketModel() : model(this->buffer(), 4) {}
    MetaBinaryPacketModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::proto::MetaBinaryPacket>::fbe_type(); }

    // Check if the struct value is valid
    bool Verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::proto::MetaBinaryPacket& value);
    // Deserialize the struct value
    size_t deserialize(::proto::MetaBinaryPacket& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::proto::MetaBinaryPacket> model;
};

} // namespace proto

// Fast Binary Encoding ::proto::LiDARPosition field model
template <>
class FieldModel<::proto::LiDARPosition>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 10; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool Verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::proto::LiDARPosition& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::proto::LiDARPosition& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::proto::LiDARPosition& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::proto::LiDARPosition& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<int32_t> idx;
    FieldModel<int32_t> x;
    FieldModel<int32_t> y;
    FieldModel<float> originPercentX;
    FieldModel<float> originPercentY;
    FieldModel<float> percentX;
    FieldModel<float> percentY;
};

namespace proto {

// Fast Binary Encoding LiDARPosition model
class LiDARPositionModel : public FBE::Model
{
public:
    LiDARPositionModel() : model(this->buffer(), 4) {}
    LiDARPositionModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::proto::LiDARPosition>::fbe_type(); }

    // Check if the struct value is valid
    bool Verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::proto::LiDARPosition& value);
    // Deserialize the struct value
    size_t deserialize(::proto::LiDARPosition& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::proto::LiDARPosition> model;
};

} // namespace proto

// Fast Binary Encoding ::proto::LiDARFrameData field model
template <>
class FieldModel<::proto::LiDARFrameData>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 11; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool Verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::proto::LiDARFrameData& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::proto::LiDARFrameData& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::proto::LiDARFrameData& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::proto::LiDARFrameData& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<std::string> screen;
    FieldModelVector<::proto::LiDARPosition> newTouches;
    FieldModelVector<::proto::LiDARPosition> removeTouches;
    FieldModelVector<::proto::LiDARPosition> updateTouches;
};

namespace proto {

// Fast Binary Encoding LiDARFrameData model
class LiDARFrameDataModel : public FBE::Model
{
public:
    LiDARFrameDataModel() : model(this->buffer(), 4) {}
    LiDARFrameDataModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::proto::LiDARFrameData>::fbe_type(); }

    // Check if the struct value is valid
    bool Verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::proto::LiDARFrameData& value);
    // Deserialize the struct value
    size_t deserialize(::proto::LiDARFrameData& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::proto::LiDARFrameData> model;
};

} // namespace proto

// Fast Binary Encoding ::proto::MetaMessage field model
template <>
class FieldModel<::proto::MetaMessage>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool Verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::proto::MetaMessage& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::proto::MetaMessage& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::proto::MetaMessage& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::proto::MetaMessage& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<::proto::MetaPacket> body;
};

namespace proto {

// Fast Binary Encoding MetaMessage model
class MetaMessageModel : public FBE::Model
{
public:
    MetaMessageModel() : model(this->buffer(), 4) {}
    MetaMessageModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::proto::MetaMessage>::fbe_type(); }

    // Check if the struct value is valid
    bool Verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::proto::MetaMessage& value);
    // Deserialize the struct value
    size_t deserialize(::proto::MetaMessage& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::proto::MetaMessage> model;
};

} // namespace proto

// Fast Binary Encoding ::proto::MetaBinaryMessage field model
template <>
class FieldModel<::proto::MetaBinaryMessage>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 2; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool Verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::proto::MetaBinaryMessage& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::proto::MetaBinaryMessage& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::proto::MetaBinaryMessage& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::proto::MetaBinaryMessage& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<::proto::MetaBinaryPacket> body;
};

namespace proto {

// Fast Binary Encoding MetaBinaryMessage model
class MetaBinaryMessageModel : public FBE::Model
{
public:
    MetaBinaryMessageModel() : model(this->buffer(), 4) {}
    MetaBinaryMessageModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::proto::MetaBinaryMessage>::fbe_type(); }

    // Check if the struct value is valid
    bool Verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::proto::MetaBinaryMessage& value);
    // Deserialize the struct value
    size_t deserialize(::proto::MetaBinaryMessage& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::proto::MetaBinaryMessage> model;
};

} // namespace proto

// Fast Binary Encoding ::proto::LiDARMapperMessage field model
template <>
class FieldModel<::proto::LiDARMapperMessage>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 3; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool Verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::proto::LiDARMapperMessage& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::proto::LiDARMapperMessage& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::proto::LiDARMapperMessage& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::proto::LiDARMapperMessage& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<::proto::LiDARFrameData> body;
};

namespace proto {

// Fast Binary Encoding LiDARMapperMessage model
class LiDARMapperMessageModel : public FBE::Model
{
public:
    LiDARMapperMessageModel() : model(this->buffer(), 4) {}
    LiDARMapperMessageModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::proto::LiDARMapperMessage>::fbe_type(); }

    // Check if the struct value is valid
    bool Verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::proto::LiDARMapperMessage& value);
    // Deserialize the struct value
    size_t deserialize(::proto::LiDARMapperMessage& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::proto::LiDARMapperMessage> model;
};

} // namespace proto

} // namespace FBE
