//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: meta.lib.proto.fbe
// FBE version: 1.14.2.0
//------------------------------------------------------------------------------

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4065) // C4065: switch statement contains 'default' but no 'case' labels
#endif

#include "proto_protocol.h"

#include "PMLibrary/Public/PMLogMacros.h"

namespace FBE {

namespace proto {

size_t Sender::send(const ::proto::MetaMessage& value)
{
    // Serialize the value into the FBE stream
    size_t serialized = MetaMessageModel.serialize(value);
    assert((serialized > 0) && "proto::MetaMessage serialization failed!");
    assert(MetaMessageModel.Verify() && "proto::MetaMessage validation failed!");

    // Log the value
    if (this->_logging)
    {
        std::string message = value.string();
        this->onSendLog(message);
    }

    // Send the serialized value
    return this->send_serialized(serialized);
}

size_t Sender::send(const ::proto::MetaBinaryMessage& value)
{
    // Serialize the value into the FBE stream
    size_t serialized = MetaBinaryMessageModel.serialize(value);
    assert((serialized > 0) && "proto::MetaBinaryMessage serialization failed!");
    assert(MetaBinaryMessageModel.Verify() && "proto::MetaBinaryMessage validation failed!");

    // Log the value
    if (this->_logging)
    {
        std::string message = value.string();
        this->onSendLog(message);
    }

    // Send the serialized value
    return this->send_serialized(serialized);
}

size_t Sender::send(const ::proto::LiDARMapperMessage& value)
{
    // Serialize the value into the FBE stream
    size_t serialized = LiDARMapperMessageModel.serialize(value);
    assert((serialized > 0) && "proto::LiDARMapperMessage serialization failed!");
    assert(LiDARMapperMessageModel.Verify() && "proto::LiDARMapperMessage validation failed!");

    // Log the value
    if (this->_logging)
    {
        std::string message = value.string();
        this->onSendLog(message);
    }

    // Send the serialized value
    return this->send_serialized(serialized);
}

bool Receiver::onReceive(size_t type, const void* data, size_t size)
{
    switch (type)
    {
        case FBE::proto::MetaMessageModel::fbe_type():
        {
            // Deserialize the value from the FBE stream
            MetaMessageModel.attach(data, size);
            assert(MetaMessageModel.Verify() && "proto::MetaMessage validation failed!");
            [[maybe_unused]] size_t deserialized = MetaMessageModel.deserialize(MetaMessageValue);
            assert((deserialized > 0) && "proto::MetaMessage deserialization failed!");

            // Log the value
            if (this->_logging)
            {
                std::string message = MetaMessageValue.string();
                this->onReceiveLog(message);
            }

            // Call receive handler with deserialized value
            onReceive(MetaMessageValue);
            return true;
        }
        case FBE::proto::MetaBinaryMessageModel::fbe_type():
        {
            // Deserialize the value from the FBE stream
            MetaBinaryMessageModel.attach(data, size);
            assert(MetaBinaryMessageModel.Verify() && "proto::MetaBinaryMessage validation failed!");
            [[maybe_unused]] size_t deserialized = MetaBinaryMessageModel.deserialize(MetaBinaryMessageValue);
            assert((deserialized > 0) && "proto::MetaBinaryMessage deserialization failed!");

            // Log the value
            if (this->_logging)
            {
                std::string message = MetaBinaryMessageValue.string();
                this->onReceiveLog(message);
            }

            // Call receive handler with deserialized value
            onReceive(MetaBinaryMessageValue);
            return true;
        }
        case FBE::proto::LiDARMapperMessageModel::fbe_type():
        {
            // Deserialize the value from the FBE stream
            LiDARMapperMessageModel.attach(data, size);
            assert(LiDARMapperMessageModel.Verify() && "proto::LiDARMapperMessage validation failed!");
            [[maybe_unused]] size_t deserialized = LiDARMapperMessageModel.deserialize(LiDARMapperMessageValue);
            assert((deserialized > 0) && "proto::LiDARMapperMessage deserialization failed!");

            // Log the value
            if (this->_logging)
            {
                std::string message = LiDARMapperMessageValue.string();
                this->onReceiveLog(message);
            }

            // Call receive handler with deserialized value
            onReceive(LiDARMapperMessageValue);
            return true;
        }
        default:
            break;
    }

    return false;
}

bool Proxy::onReceive(size_t type, const void* data, size_t size)
{
    switch (type)
    {
        case FBE::proto::MetaMessageModel::fbe_type():
        {
            // Attach the FBE stream to the proxy model
            MetaMessageModel.attach(data, size);
            assert(MetaMessageModel.Verify() && "proto::MetaMessage validation failed!");

            size_t fbe_begin = MetaMessageModel.model.get_begin();
            if (fbe_begin == 0)
                return false;
            // Call proxy handler
            onProxy(MetaMessageModel, type, data, size);
            MetaMessageModel.model.get_end(fbe_begin);
            return true;
        }
        case FBE::proto::MetaBinaryMessageModel::fbe_type():
        {
            // Attach the FBE stream to the proxy model
            MetaBinaryMessageModel.attach(data, size);
            assert(MetaBinaryMessageModel.Verify() && "proto::MetaBinaryMessage validation failed!");

            size_t fbe_begin = MetaBinaryMessageModel.model.get_begin();
            if (fbe_begin == 0)
                return false;
            // Call proxy handler
            onProxy(MetaBinaryMessageModel, type, data, size);
            MetaBinaryMessageModel.model.get_end(fbe_begin);
            return true;
        }
        case FBE::proto::LiDARMapperMessageModel::fbe_type():
        {
            // Attach the FBE stream to the proxy model
            LiDARMapperMessageModel.attach(data, size);
            assert(LiDARMapperMessageModel.Verify() && "proto::LiDARMapperMessage validation failed!");

            size_t fbe_begin = LiDARMapperMessageModel.model.get_begin();
            if (fbe_begin == 0)
                return false;
            // Call proxy handler
            onProxy(LiDARMapperMessageModel, type, data, size);
            LiDARMapperMessageModel.model.get_end(fbe_begin);
            return true;
        }
        default: break;
    }

    return false;
}

void Client::reset_requests()
{
    Sender::reset();
    Receiver::reset();
}

void Client::watchdog_requests(uint64_t utc)
{
}

} // namespace proto

} // namespace FBE

#if defined(_MSC_VER)
#pragma warning(pop)
#endif
